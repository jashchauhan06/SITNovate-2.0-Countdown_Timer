{"ast":null,"code":"import { db } from '../firebase';\nimport { ref, set, onValue, get } from 'firebase/database';\nconst TIMER_REF = 'timer';\nconst DEFAULT_STATE = {\n  isRunning: false,\n  endTime: null,\n  remainingTime: 24 * 60 * 60 * 1000\n};\n\n// Write timer state to Firebase\nexport function saveTimerState(state) {\n  return set(ref(db, TIMER_REF), state);\n}\n\n// One-time read of timer state\nexport async function getTimerState() {\n  const snapshot = await get(ref(db, TIMER_REF));\n  return snapshot.exists() ? snapshot.val() : {\n    ...DEFAULT_STATE\n  };\n}\n\n// Real-time listener — calls callback whenever timer state changes in Firebase\nexport function subscribeToTimer(callback) {\n  const timerRef = ref(db, TIMER_REF);\n  const unsubscribe = onValue(timerRef, snapshot => {\n    const state = snapshot.exists() ? snapshot.val() : {\n      ...DEFAULT_STATE\n    };\n    callback(state);\n  });\n  return unsubscribe;\n}\n\n// GitHub Push Timer\nconst GITHUB_TIMER_REF = 'githubPushTimer';\nconst THREE_HOURS = 3 * 60 * 60 * 1000;\n\n// Calculate which push cycle we're in based on the main timer\nfunction calculatePushCycle(mainTimerRemainingMs) {\n  const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;\n  const elapsed = TWENTY_FOUR_HOURS - mainTimerRemainingMs;\n  const pushNumber = Math.floor(elapsed / THREE_HOURS) + 1;\n  const timeInCurrentCycle = elapsed % THREE_HOURS;\n  const timeLeftInCycle = THREE_HOURS - timeInCurrentCycle;\n  return {\n    pushNumber: Math.min(pushNumber, 8),\n    // Max 8 pushes in 24 hours\n    timeLeft: timeLeftInCycle\n  };\n}\n\n// Save GitHub timer data to Firebase\nexport function saveGitHubTimer(endTime, pushCount) {\n  return set(ref(db, GITHUB_TIMER_REF), {\n    endTime,\n    pushCount\n  });\n}\n\n// Get GitHub timer data\nexport async function getGitHubTimer() {\n  const snapshot = await get(ref(db, GITHUB_TIMER_REF));\n  if (snapshot.exists()) {\n    return snapshot.val();\n  }\n  // Initialize with 3 hours from now if not exists\n  const newEndTime = Date.now() + THREE_HOURS;\n  await saveGitHubTimer(newEndTime, 1);\n  return {\n    endTime: newEndTime,\n    pushCount: 1\n  };\n}\n\n// Sync GitHub timer with main timer\nexport async function syncGitHubTimerWithMain() {\n  const mainTimerState = await getTimerState();\n  if (!mainTimerState.isRunning) {\n    // If main timer is not running, don't update GitHub timer\n    return;\n  }\n  let remainingTime = mainTimerState.remainingTime;\n  if (mainTimerState.endTime) {\n    remainingTime = Math.max(0, mainTimerState.endTime - Date.now());\n  }\n  const {\n    pushNumber,\n    timeLeft\n  } = calculatePushCycle(remainingTime);\n  const newEndTime = Date.now() + timeLeft;\n  await saveGitHubTimer(newEndTime, pushNumber);\n}\n\n// Real-time listener for GitHub timer that syncs with main timer\nexport function subscribeToGitHubTimer(callback) {\n  const timerRef = ref(db, TIMER_REF);\n  const unsubscribe = onValue(timerRef, async snapshot => {\n    const mainState = snapshot.exists() ? snapshot.val() : {\n      ...DEFAULT_STATE\n    };\n    if (!mainState.isRunning) {\n      // Timer is stopped/paused, calculate based on remaining time\n      const remainingTime = mainState.remainingTime || 0;\n      const {\n        pushNumber,\n        timeLeft\n      } = calculatePushCycle(remainingTime);\n\n      // Return the time left in current cycle, but don't count down\n      callback(Date.now() + timeLeft, pushNumber, false);\n      return;\n    }\n    let remainingTime = mainState.remainingTime;\n    if (mainState.endTime) {\n      remainingTime = Math.max(0, mainState.endTime - Date.now());\n    }\n    const {\n      pushNumber,\n      timeLeft\n    } = calculatePushCycle(remainingTime);\n    const endTime = Date.now() + timeLeft;\n    callback(endTime, pushNumber, true);\n  });\n  return unsubscribe;\n}\n\n// Reset GitHub timer (add 3 hours from now and increment count)\nexport async function resetGitHubTimer() {\n  const currentData = await getGitHubTimer();\n  const newEndTime = Date.now() + THREE_HOURS;\n  const newPushCount = currentData.pushCount + 1;\n  await saveGitHubTimer(newEndTime, newPushCount);\n  return {\n    endTime: newEndTime,\n    pushCount: newPushCount\n  };\n}","map":{"version":3,"names":["db","ref","set","onValue","get","TIMER_REF","DEFAULT_STATE","isRunning","endTime","remainingTime","saveTimerState","state","getTimerState","snapshot","exists","val","subscribeToTimer","callback","timerRef","unsubscribe","GITHUB_TIMER_REF","THREE_HOURS","calculatePushCycle","mainTimerRemainingMs","TWENTY_FOUR_HOURS","elapsed","pushNumber","Math","floor","timeInCurrentCycle","timeLeftInCycle","min","timeLeft","saveGitHubTimer","pushCount","getGitHubTimer","newEndTime","Date","now","syncGitHubTimerWithMain","mainTimerState","max","subscribeToGitHubTimer","mainState","resetGitHubTimer","currentData","newPushCount"],"sources":["J:/Github/SITNovate-2.0-Countdown_Timer/src/utils/timerStorage.js"],"sourcesContent":["import { db } from '../firebase';\r\nimport { ref, set, onValue, get } from 'firebase/database';\r\n\r\nconst TIMER_REF = 'timer';\r\n\r\nconst DEFAULT_STATE = {\r\n  isRunning: false,\r\n  endTime: null,\r\n  remainingTime: 24 * 60 * 60 * 1000\r\n};\r\n\r\n// Write timer state to Firebase\r\nexport function saveTimerState(state) {\r\n  return set(ref(db, TIMER_REF), state);\r\n}\r\n\r\n// One-time read of timer state\r\nexport async function getTimerState() {\r\n  const snapshot = await get(ref(db, TIMER_REF));\r\n  return snapshot.exists() ? snapshot.val() : { ...DEFAULT_STATE };\r\n}\r\n\r\n// Real-time listener — calls callback whenever timer state changes in Firebase\r\nexport function subscribeToTimer(callback) {\r\n  const timerRef = ref(db, TIMER_REF);\r\n  const unsubscribe = onValue(timerRef, (snapshot) => {\r\n    const state = snapshot.exists() ? snapshot.val() : { ...DEFAULT_STATE };\r\n    callback(state);\r\n  });\r\n  return unsubscribe;\r\n}\r\n\r\n// GitHub Push Timer\r\nconst GITHUB_TIMER_REF = 'githubPushTimer';\r\nconst THREE_HOURS = 3 * 60 * 60 * 1000;\r\n\r\n// Calculate which push cycle we're in based on the main timer\r\nfunction calculatePushCycle(mainTimerRemainingMs) {\r\n  const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;\r\n  const elapsed = TWENTY_FOUR_HOURS - mainTimerRemainingMs;\r\n  const pushNumber = Math.floor(elapsed / THREE_HOURS) + 1;\r\n  const timeInCurrentCycle = elapsed % THREE_HOURS;\r\n  const timeLeftInCycle = THREE_HOURS - timeInCurrentCycle;\r\n  \r\n  return {\r\n    pushNumber: Math.min(pushNumber, 8), // Max 8 pushes in 24 hours\r\n    timeLeft: timeLeftInCycle\r\n  };\r\n}\r\n\r\n// Save GitHub timer data to Firebase\r\nexport function saveGitHubTimer(endTime, pushCount) {\r\n  return set(ref(db, GITHUB_TIMER_REF), { endTime, pushCount });\r\n}\r\n\r\n// Get GitHub timer data\r\nexport async function getGitHubTimer() {\r\n  const snapshot = await get(ref(db, GITHUB_TIMER_REF));\r\n  if (snapshot.exists()) {\r\n    return snapshot.val();\r\n  }\r\n  // Initialize with 3 hours from now if not exists\r\n  const newEndTime = Date.now() + THREE_HOURS;\r\n  await saveGitHubTimer(newEndTime, 1);\r\n  return { endTime: newEndTime, pushCount: 1 };\r\n}\r\n\r\n// Sync GitHub timer with main timer\r\nexport async function syncGitHubTimerWithMain() {\r\n  const mainTimerState = await getTimerState();\r\n  \r\n  if (!mainTimerState.isRunning) {\r\n    // If main timer is not running, don't update GitHub timer\r\n    return;\r\n  }\r\n  \r\n  let remainingTime = mainTimerState.remainingTime;\r\n  if (mainTimerState.endTime) {\r\n    remainingTime = Math.max(0, mainTimerState.endTime - Date.now());\r\n  }\r\n  \r\n  const { pushNumber, timeLeft } = calculatePushCycle(remainingTime);\r\n  const newEndTime = Date.now() + timeLeft;\r\n  \r\n  await saveGitHubTimer(newEndTime, pushNumber);\r\n}\r\n\r\n// Real-time listener for GitHub timer that syncs with main timer\r\nexport function subscribeToGitHubTimer(callback) {\r\n  const timerRef = ref(db, TIMER_REF);\r\n  \r\n  const unsubscribe = onValue(timerRef, async (snapshot) => {\r\n    const mainState = snapshot.exists() ? snapshot.val() : { ...DEFAULT_STATE };\r\n    \r\n    if (!mainState.isRunning) {\r\n      // Timer is stopped/paused, calculate based on remaining time\r\n      const remainingTime = mainState.remainingTime || 0;\r\n      const { pushNumber, timeLeft } = calculatePushCycle(remainingTime);\r\n      \r\n      // Return the time left in current cycle, but don't count down\r\n      callback(Date.now() + timeLeft, pushNumber, false);\r\n      return;\r\n    }\r\n    \r\n    let remainingTime = mainState.remainingTime;\r\n    if (mainState.endTime) {\r\n      remainingTime = Math.max(0, mainState.endTime - Date.now());\r\n    }\r\n    \r\n    const { pushNumber, timeLeft } = calculatePushCycle(remainingTime);\r\n    const endTime = Date.now() + timeLeft;\r\n    \r\n    callback(endTime, pushNumber, true);\r\n  });\r\n  \r\n  return unsubscribe;\r\n}\r\n\r\n// Reset GitHub timer (add 3 hours from now and increment count)\r\nexport async function resetGitHubTimer() {\r\n  const currentData = await getGitHubTimer();\r\n  const newEndTime = Date.now() + THREE_HOURS;\r\n  const newPushCount = currentData.pushCount + 1;\r\n  await saveGitHubTimer(newEndTime, newPushCount);\r\n  return { endTime: newEndTime, pushCount: newPushCount };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}